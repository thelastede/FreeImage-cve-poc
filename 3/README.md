# Integer overflow vulnerability in FreeImage

---

FreeImage is an image processing library. An integer overflow vulnerability exits in FreeImageIO.cpp::_MemoryReadProc in FreeImage 3.18.0, which will futher cause buffer overflow that allows attackers to conduct information disclosure , denial-of-service attacks and arbitrary code execution

---

## version

3.18.0

---

## Vulnerability causes

When LoadBmp image, it will go to LoadWindowsBMP, the source code of LoadWindowsBMP is as follows

~~~c
static FIBITMAP *
LoadWindowsBMP(FreeImageIO *io, fi_handle handle, int flags, unsigned bitmap_bits_offset, int type) {
	FIBITMAP *dib = NULL;

	try {
		BOOL header_only = (flags & FIF_LOAD_NOPIXELS) == FIF_LOAD_NOPIXELS;

		// load the info header

		BITMAPINFOHEADER bih;

		io->read_proc(&bih, sizeof(BITMAPINFOHEADER), 1, handle); // read relevant attribute
#ifdef FREEIMAGE_BIGENDIAN
		SwapInfoHeader(&bih);
#endif

		// keep some general information about the bitmap

		unsigned used_colors	= bih.biClrUsed;
		int width				= bih.biWidth;
		int height				= bih.biHeight;		// WARNING: height can be < 0 => check each call using 'height' as a parameter
		unsigned bit_count		= bih.biBitCount;
		unsigned compression	= bih.biCompression;
		unsigned pitch			= CalculatePitch(CalculateLine(width, bit_count));

		switch (bit_count) {
			case 1 :
			case 4 :
			case 8 :
			{
				if ((used_colors == 0) || (used_colors > CalculateUsedPaletteEntries(bit_count))) {
					used_colors = CalculateUsedPaletteEntries(bit_count);
				}
				
				// allocate enough memory to hold the bitmap (header, palette, pixels) and read the palette

				dib = FreeImage_AllocateHeader(header_only, width, height, bit_count);
				if (dib == NULL) {
					throw FI_MSG_ERROR_DIB_MEMORY;
				}

				// set resolution information
				FreeImage_SetDotsPerMeterX(dib, bih.biXPelsPerMeter);
				FreeImage_SetDotsPerMeterY(dib, bih.biYPelsPerMeter);

				// seek to the end of the header (depending on the BMP header version)
				// type == sizeof(BITMAPVxINFOHEADER)
				switch(type) {
					case 40:	// sizeof(BITMAPINFOHEADER) - all Windows versions since Windows 3.0
						break;
					case 52:	// sizeof(BITMAPV2INFOHEADER) (undocumented)
					case 56:	// sizeof(BITMAPV3INFOHEADER) (undocumented)
					case 108:	// sizeof(BITMAPV4HEADER) - all Windows versions since Windows 95/NT4 (not supported)
					case 124:	// sizeof(BITMAPV5HEADER) - Windows 98/2000 and newer (not supported)
						io->seek_proc(handle, (long)(type - sizeof(BITMAPINFOHEADER)), SEEK_CUR);
						break;
				}
				
				// load the palette

				io->read_proc(FreeImage_GetPalette(dib), used_colors * sizeof(RGBQUAD), 1, handle);
#if FREEIMAGE_COLORORDER == FREEIMAGE_COLORORDER_RGB
				RGBQUAD *pal = FreeImage_GetPalette(dib);
				for(int i = 0; i < used_colors; i++) {
					INPLACESWAP(pal[i].rgbRed, pal[i].rgbBlue);
				}
#endif

				if(header_only) {
					// header only mode
					return dib;
				}

				// seek to the actual pixel data.
				// this is needed because sometimes the palette is larger than the entries it contains predicts
				io->seek_proc(handle, bitmap_bits_offset, SEEK_SET);

				// read the pixel data

				switch (compression) {
					case BI_RGB :
						if( LoadPixelData(io, handle, dib, height, pitch, bit_count) ) {
							return dib;
						} else {
							throw "Error encountered while decoding BMP data";
						}
						break;

					case BI_RLE4 :
						if( LoadPixelDataRLE4(io, handle, width, height, dib) ) {
							return dib;
						} else {
							throw "Error encountered while decoding RLE4 BMP data";
						}
						break;

					case BI_RLE8 :
						if( LoadPixelDataRLE8(io, handle, width, height, dib) ) {
							return dib;
						} else {
							throw "Error encountered while decoding RLE8 BMP data";
						}
						break;

					default :
						throw FI_MSG_ERROR_UNSUPPORTED_COMPRESSION;
				}
			}
			break; // 1-, 4-, 8-bit

			case 16 :
			{
				int use_bitfields = 0;
				if (bih.biCompression == BI_BITFIELDS) use_bitfields = 3;
				else if (bih.biCompression == BI_ALPHABITFIELDS) use_bitfields = 4;
				else if (type == 52) use_bitfields = 3;
				else if (type >= 56) use_bitfields = 4;
				
				if (use_bitfields > 0) {
 					DWORD bitfields[4];
					io->read_proc(bitfields, use_bitfields * sizeof(DWORD), 1, handle);
					dib = FreeImage_AllocateHeader(header_only, width, height, bit_count, bitfields[0], bitfields[1], bitfields[2]);
				} else {
					dib = FreeImage_AllocateHeader(header_only, width, height, bit_count, FI16_555_RED_MASK, FI16_555_GREEN_MASK, FI16_555_BLUE_MASK);
				}

				if (dib == NULL) {
					throw FI_MSG_ERROR_DIB_MEMORY;						
				}

				// set resolution information
				FreeImage_SetDotsPerMeterX(dib, bih.biXPelsPerMeter);
				FreeImage_SetDotsPerMeterY(dib, bih.biYPelsPerMeter);

				if(header_only) {
					// header only mode
					return dib;
				}
				
				// seek to the actual pixel data
				io->seek_proc(handle, bitmap_bits_offset, SEEK_SET);

				// load pixel data and swap as needed if OS is Big Endian
				LoadPixelData(io, handle, dib, height, pitch, bit_count);

				return dib;
			}
			break; // 16-bit

			case 24 :
			case 32 :
			{
				int use_bitfields = 0;
				if (bih.biCompression == BI_BITFIELDS) use_bitfields = 3;
				else if (bih.biCompression == BI_ALPHABITFIELDS) use_bitfields = 4;
				else if (type == 52) use_bitfields = 3;
				else if (type >= 56) use_bitfields = 4;

 				if (use_bitfields > 0) {
					DWORD bitfields[4];
					io->read_proc(bitfields, use_bitfields * sizeof(DWORD), 1, handle);
					dib = FreeImage_AllocateHeader(header_only, width, height, bit_count, bitfields[0], bitfields[1], bitfields[2]);
				} else {
					if( bit_count == 32 ) {
						dib = FreeImage_AllocateHeader(header_only, width, height, bit_count, FI_RGBA_RED_MASK, FI_RGBA_GREEN_MASK, FI_RGBA_BLUE_MASK);
					} else {
						dib = FreeImage_AllocateHeader(header_only, width, height, bit_count, FI_RGBA_RED_MASK, FI_RGBA_GREEN_MASK, FI_RGBA_BLUE_MASK);
					}
				}

				if (dib == NULL) {
					throw FI_MSG_ERROR_DIB_MEMORY;
				}

				// set resolution information
				FreeImage_SetDotsPerMeterX(dib, bih.biXPelsPerMeter);
				FreeImage_SetDotsPerMeterY(dib, bih.biYPelsPerMeter);

				if(header_only) {
					// header only mode
					return dib;
				}

				// Skip over the optional palette 
				// A 24 or 32 bit DIB may contain a palette for faster color reduction
				// i.e. you can have (FreeImage_GetColorsUsed(dib) > 0)

				// seek to the actual pixel data
				io->seek_proc(handle, bitmap_bits_offset, SEEK_SET);

				// read in the bitmap bits
				// load pixel data and swap as needed if OS is Big Endian
				LoadPixelData(io, handle, dib, height, pitch, bit_count);

				// check if the bitmap contains transparency, if so enable it in the header

				FreeImage_SetTransparent(dib, (FreeImage_GetColorType(dib) == FIC_RGBALPHA));

				return dib;
			}
			break; // 24-, 32-bit
		}
	} catch(const char *message) {
		if(dib) {
			FreeImage_Unload(dib);
		}
		if(message) {
			FreeImage_OutputMessageProc(s_format_id, message);
		}
	}

	return NULL;
}
~~~

When importing a BMP image, relevant attribute information is read, such as width and length.

~~~c
io->read_proc(&bih, sizeof(BITMAPINFOHEADER), 1, handle);	// read relevant attribute
~~~

Information such as the length and width of the image is then assigned to the appropriate variables. Note that height has special handling for cases less than 0, but width does not, however width is still stored as a signed integer. In the pitch calculation, the width is inputed as an argument.

~~~c
unsigned used_colors	= bih.biClrUsed;
		int width				= bih.biWidth;
		int height				= bih.biHeight;		// WARNING: height can be < 0 => check each call using 'height' as a parameter
		unsigned bit_count		= bih.biBitCount;
		unsigned compression	= bih.biCompression;
		unsigned pitch			= CalculatePitch(CalculateLine(width, bit_count));
~~~

CalculateLine and CalculatePitch are defined as follows, and as you can see, the pitch is temporarily converted to an unsigned integer when it is calculated.

~~~c
inline unsigned
CalculateLine(const unsigned width, const unsigned bitdepth) {
	return (unsigned)( ((unsigned long long)width * bitdepth + 7) / 8 );
}

inline unsigned
CalculatePitch(const unsigned line) {
	return (line + 3) & ~3;
}
~~~

When compression is BI_RGB, it will enter the LoadPixelData function, and at this time, it will pass the pitch as a parameter.

~~~c
LoadPixelData(io, handle, dib, height, pitch, bit_count)
~~~

The source code for LoadPixelData is as follows, and we can notice that when height is greater than 0, the value of height * pitch is passed into io->read_proc. So it is actually possible to construct suitable inputs such that 0xffffffff >= height * pitch >= 0x80000000.

~~~c
static BOOL 
LoadPixelData(FreeImageIO *io, fi_handle handle, FIBITMAP *dib, int height, unsigned pitch, unsigned bit_count) {
	unsigned count = 0;

	// Load pixel data
	// NB: height can be < 0 for BMP data
	if (height > 0) {
		count = io->read_proc((void *)FreeImage_GetBits(dib), height * pitch, 1, handle);
		if(count != 1) {
			return FALSE;
		}
	} else {
		int positiveHeight = abs(height);
		for (int c = 0; c < positiveHeight; ++c) {
			count = io->read_proc((void *)FreeImage_GetScanLine(dib, positiveHeight - c - 1), pitch, 1, handle);
			if(count != 1) {
				return FALSE;
			}
		}
	}

	// swap as needed
#ifdef FREEIMAGE_BIGENDIAN
	if (bit_count == 16) {
		for(unsigned y = 0; y < FreeImage_GetHeight(dib); y++) {
			WORD *pixel = (WORD *)FreeImage_GetScanLine(dib, y);
			for(unsigned x = 0; x < FreeImage_GetWidth(dib); x++) {
				SwapShort(pixel);
				pixel++;
			}
		}
	}
#endif
#if FREEIMAGE_COLORORDER == FREEIMAGE_COLORORDER_RGB
	if (bit_count == 24 || bit_count == 32) {
		for(unsigned y = 0; y < FreeImage_GetHeight(dib); y++) {
			BYTE *pixel = FreeImage_GetScanLine(dib, y);
			for(unsigned x = 0; x < FreeImage_GetWidth(dib); x++) {
				INPLACESWAP(pixel[0], pixel[2]);
				pixel += (bit_count >> 3);
			}
		}
	}
#endif

	return TRUE;
}
~~~

When the following line of code is called, it goes to _MemoryReadProc

~~~c
count = io->read_proc((void *)FreeImage_GetBits(dib), height * pitch, 1, handle);
~~~

When entering the _MemoryReadProc function, size = height * pitch. Notice that there is a comparison in the function, however, during the comparison, size is temporarily converted to signed integer. So if size > 0x80000000, it will be treated as a negative number at this point. In turn, skip this if and go to the following memcpy

~~~c
unsigned DLL_CALLCONV 
_MemoryReadProc(void *buffer, unsigned size, unsigned count, fi_handle handle) {
	unsigned x;

	FIMEMORYHEADER *mem_header = (FIMEMORYHEADER*)(((FIMEMORY*)handle)->data);

	for(x = 0; x < count; x++) {
		long remaining_bytes = mem_header->file_length - mem_header->current_position;
		//if there isn't size bytes left to read, set pos to eof and return a short count
		if( remaining_bytes < (long)size ) {
			if(remaining_bytes > 0) {
				memcpy( buffer, (char *)mem_header->data + mem_header->current_position, remaining_bytes );
			}
			mem_header->current_position = mem_header->file_length;
			break;
		}
		//copy size bytes count times
		memcpy( buffer, (char *)mem_header->data + mem_header->current_position, size );
		mem_header->current_position += size;
		buffer = (char *)buffer + size;
	}
	return x;
}
~~~

In the following memcpy, an unsigned integer size is given as an argument, and since the size value is large at this point, a very large number of characters are copied from (char *)mem_header->data to the buffer, resulting in both heap out-of-bounds reads to mem_header->data and heap overflow writes to the buffer.

~~~c
memcpy( buffer, (char *)mem_header->data + mem_header->current_position, size );
~~~



---

## Vulnerability reproduce

Run the following command in windows

~~~
example.exe img
~~~

If you run the sample with the windbg debugger, you can see the following message

~~~
(8b44.7d0): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
FreeImage+0x265e37:
00000001`80265e37 0f10441110      movups  xmm0,xmmword ptr [rcx+rdx+10h] ds:000001ff`dac7dffe=????????????????????????????????
~~~

Since FreeImage.dll has no symbol table, the stack looks as follows

~~~c
[0x0]   FreeImage + 0x265e37!FreeImage+0x265e37   0xbbaf98f6d8   0x1802995be   
[0x1]   FreeImage!FreeImage_OutputMessageProc+0x5ce   0xbbaf98f6e0   0x1802a381d   
[0x2]   FreeImage!FreeImage_DeInitialise+0x259d   0xbbaf98f720   0x1802a2d39   
[0x3]   FreeImage!FreeImage_DeInitialise+0x1ab9   0xbbaf98f760   0x1802a1d6f   
[0x4]   FreeImage!FreeImage_DeInitialise+0xaef   0xbbaf98f8a0   0x1802a08a4   
[0x5]   FreeImage!FreeImage_LoadFromHandle+0xd4   0xbbaf98f8f0   0x18029a72f   
[0x6]   FreeImage!FreeImage_LoadFromMemory+0x4f   0xbbaf98f930   0x7ff6b81a119a   
[0x7]   FuzzTest!testLoadMemIO+0x85   0xbbaf98f980   0x7ff6b81a13f8   
[0x8]   FuzzTest!FuzzFunctions+0x16b   0xbbaf98f980   0x7ff6b81a13f8   
[0x9]   FuzzTest!main+0x19a   0xbbaf98f980   0x7ff6b81a13f8   
[0xa]   FuzzTest!invoke_main+0x22   0xbbaf98f9f0   0x7ffb92ce257d   
[0xb]   FuzzTest!__scrt_common_main_seh+0x10c   0xbbaf98f9f0   0x7ffb92ce257d   
[0xc]   KERNEL32!BaseThreadInitThunk+0x1d   0xbbaf98fa30   0x7ffb9382aa78   
[0xd]   ntdll!RtlUserThreadStart+0x28   0xbbaf98fa60   0x0   

~~~

