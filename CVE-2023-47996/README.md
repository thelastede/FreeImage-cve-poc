# Integer Overflow vulnerability in FreeImage

---

FreeImage is an image processing library. An integer overflow vulnerability exits in Exif.cpp::jpeg_read_exif_dir in FreeImage 3.18.0 allows attackers to conduct information disclosure and denial-of-service attacks.

---

## version

3.18.0

---

## Vulnerability causes

When calling FreeImage_LoadU to parse the image in jpeg format, it will further call to jpeg_read_exif_dir, at this time, in order to read the thumbnail information, it will read the ulValue value in dirEntry. When the tagNumber of dirEntry is 0x0201, the ulValue value records the offset of the relevant data relative to the TIFF header.

The source code for the jpeg_read_exif_dir function is as follows

~~~c
static BOOL 
jpeg_read_exif_dir(FIBITMAP *dib, const BYTE *tiffp, DWORD dwOffsetIfd0, DWORD dwLength, DWORD dwProfileOffset, BOOL msb_order, TagLib::MDMODEL starting_md_model) {
	WORD de, nde;

	std::stack<WORD>			destack;	// directory entries stack
	std::stack<const BYTE*>		ifdstack;	// IFD stack
	std::stack<TagLib::MDMODEL>	modelstack; // metadata model stack

	// Keep a list of already visited IFD to avoid stack overflows 
	// when recursive/cyclic directory structures exist. 
	// This kind of recursive Exif file was encountered with Kodak images coming from 
	// KODAK PROFESSIONAL DCS Photo Desk JPEG Export v3.2 W
	std::map<DWORD, int> visitedIFD;

	/*
	"An Image File Directory (IFD) consists of a 2-byte count of the number of directory
	entries (i.e. the number of fields), followed by a sequence of 12-byte field
	entries, followed by a 4-byte offset of the next IFD (or 0 if none)."
	The "next IFD" (1st IFD) is the thumbnail.
	*/
	#define DIR_ENTRY_ADDR(_start, _entry) (_start + 2 + (12 * _entry))

	// set the metadata model to Exif

	TagLib::MDMODEL md_model = starting_md_model;

	// set the pointer to the first IFD (0th IFD) and follow it were it leads.

	const BYTE *ifd0th = (BYTE*)tiffp + (size_t)dwOffsetIfd0;

	const BYTE *ifdp = ifd0th;

	de = 0;

	do {
		// if there is anything on the stack then pop it off
		if(!destack.empty()) {
			ifdp		= ifdstack.top();	ifdstack.pop();
			de			= destack.top();	destack.pop();
			md_model	= modelstack.top();	modelstack.pop();
		}

		// remember that we've visited this directory and entry so that we don't visit it again later
		DWORD visited = (DWORD)( (((size_t)ifdp & 0xFFFF) << 16) | (size_t)de );
		if(visitedIFD.find(visited) != visitedIFD.end()) {
			continue;
		} else {
			visitedIFD[visited] = 1;	// processed
		}

		// determine how many entries there are in the current IFD
		nde = ReadUint16(msb_order, ifdp);
		if (((size_t)(ifdp - tiffp) + 12 * nde) > (size_t)dwLength) {
			// suspicious IFD offset, ignore
			continue;
		}

		for(; de < nde; de++) {
			char *pde = NULL;	// pointer to the directory entry
			char *pval = NULL;	// pointer to the tag value
			
			// create a tag
			FITAG *tag = FreeImage_CreateTag();
			if(!tag) return FALSE;

			// point to the directory entry
			pde = (char*) DIR_ENTRY_ADDR(ifdp, de);

			// get the tag ID
			WORD tag_id = ReadUint16(msb_order, pde);
			FreeImage_SetTagID(tag, tag_id);

			// get the tag type
			WORD tag_type = (WORD)ReadUint16(msb_order, pde + 2);
            if((tag_type - 1) >= EXIF_NUM_FORMATS) {
                // a problem occured : delete the tag (not free'd after)
			    FreeImage_DeleteTag(tag);
				// break out of the for loop
				break;
            }
			FreeImage_SetTagType(tag, (FREE_IMAGE_MDTYPE)tag_type);

			// get number of components
			DWORD tag_count = ReadUint32(msb_order, pde + 4);
			FreeImage_SetTagCount(tag, tag_count);

            // check that tag length (size of the tag value in bytes) will fit in a DWORD
            unsigned tag_data_width = FreeImage_TagDataWidth(FreeImage_GetTagType(tag));
            if (tag_data_width != 0 && FreeImage_GetTagCount(tag) > ~(DWORD)0 / tag_data_width) {
                FreeImage_DeleteTag(tag);
                // jump to next entry
                continue;
            }
			FreeImage_SetTagLength(tag, FreeImage_GetTagCount(tag) * tag_data_width);

			if(FreeImage_GetTagLength(tag) <= 4) {
				// 4 bytes or less and value is in the dir entry itself
				pval = pde + 8;
			} else {
				// if its bigger than 4 bytes, the directory entry contains an offset				
				DWORD offset_value = ReadUint32(msb_order, pde + 8);
				// the offset can be relative to tiffp or to an external reference (see JPEG-XR)
				if(dwProfileOffset) {
					offset_value -= dwProfileOffset;
				}
				// first check if offset exceeds buffer, at this stage FreeImage_GetTagLength may return invalid data
				if(offset_value > dwLength) {
					// a problem occured : delete the tag (not free'd after)
					FreeImage_DeleteTag(tag);
					// jump to next entry
					continue;
				}
				// now check that length does not exceed the buffer size
				if(FreeImage_GetTagLength(tag) > dwLength - offset_value){
					// a problem occured : delete the tag (not free'd after)
					FreeImage_DeleteTag(tag);
					// jump to next entry
					continue;
				}
				pval = (char*)(tiffp + offset_value);
			}

			// check for a IFD offset
			BOOL isIFDOffset = FALSE;
			switch(FreeImage_GetTagID(tag)) {
				case TAG_EXIF_OFFSET:
				case TAG_GPS_OFFSET:
				case TAG_INTEROP_OFFSET:
				case TAG_MAKER_NOTE:
					isIFDOffset = TRUE;
					break;
			}
			if(isIFDOffset)	{
				DWORD sub_offset = 0;
				TagLib::MDMODEL next_mdmodel = md_model;
				const BYTE *next_ifd = ifdp;
				
				// get offset and metadata model
				if (FreeImage_GetTagID(tag) == TAG_MAKER_NOTE) {
					processMakerNote(dib, pval, msb_order, &sub_offset, &next_mdmodel);
					next_ifd = (BYTE*)pval + sub_offset;
				} else {
					processIFDOffset(tag, pval, msb_order, &sub_offset, &next_mdmodel);
					next_ifd = (BYTE*)tiffp + sub_offset;
				}

				if((sub_offset < dwLength) && (next_mdmodel != TagLib::UNKNOWN)) {
					// push our current directory state onto the stack
					ifdstack.push(ifdp);
					// jump to the next entry
					de++;
					destack.push(de);

					// push our current metadata model
					modelstack.push(md_model);

					// push new state onto of stack to cause a jump
					ifdstack.push(next_ifd);
					destack.push(0);

					// select a new metadata model
					modelstack.push(next_mdmodel);
					
					// delete the tag as it won't be stored nor deleted in the for() loop
					FreeImage_DeleteTag(tag);
					
					break; // break out of the for loop
				}
				else {
					// unsupported camera model, canon maker tag or something unknown
					// process as a standard tag
					processExifTag(dib, tag, pval, msb_order, md_model);
				}			

			} else {
				// process as a standard tag
				processExifTag(dib, tag, pval, msb_order, md_model);
			}
			
			// delete the tag
			FreeImage_DeleteTag(tag);

        } // for(nde)

		// additional thumbnail data is skipped

    } while (!destack.empty()); 

	//
	// --- handle thumbnail data ---
	//

	const WORD entriesCount0th = ReadUint16(msb_order, ifd0th);
	
	DWORD next_offset = ReadUint32(msb_order, DIR_ENTRY_ADDR(ifd0th, entriesCount0th));
	if((next_offset == 0) || (next_offset >= dwLength)) {
		return TRUE; //< no thumbnail
	}
	
	const BYTE* const ifd1st = (BYTE*)tiffp + next_offset;
	const WORD entriesCount1st = ReadUint16(msb_order, ifd1st);
	
	unsigned thCompression = 0;
	unsigned thOffset = 0; 
	unsigned thSize = 0; 
	
	for(int e = 0; e < entriesCount1st; e++) {

		// point to the directory entry
		const BYTE* base = DIR_ENTRY_ADDR(ifd1st, e);
		
		// check for buffer overflow
		const size_t remaining = (size_t)base + 12 - (size_t)tiffp;
		if(remaining >= dwLength) {
			// bad IFD1 directory, ignore it
			return FALSE;
		}

		// get the tag ID
		WORD tag = ReadUint16(msb_order, base);
		// get the tag type
		/*WORD type = */ReadUint16(msb_order, base + sizeof(WORD));
		// get number of components
		/*DWORD count = */ReadUint32(msb_order, base + sizeof(WORD) + sizeof(WORD));
		// get the tag value
		DWORD offset = ReadUint32(msb_order, base + sizeof(WORD) + sizeof(WORD) + sizeof(DWORD));

		switch(tag) {
			case TAG_COMPRESSION:
				// Tiff Compression Tag (should be COMPRESSION_OJPEG (6), but is not always respected)
				thCompression = offset;
				break;
			case TAG_JPEG_INTERCHANGE_FORMAT:
				// Tiff JPEGInterchangeFormat Tag
				thOffset = offset;
				break;
			case TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:
				// Tiff JPEGInterchangeFormatLength Tag
				thSize = offset;
				break;
			// ### X and Y Resolution ignored, orientation ignored
			case TAG_X_RESOLUTION:		// XResolution
			case TAG_Y_RESOLUTION:		// YResolution
			case TAG_RESOLUTION_UNIT:	// ResolutionUnit
			case TAG_ORIENTATION:		// Orientation
				break;
			default:
				break;
		}
	}
	
	if(/*thCompression != 6 ||*/ thOffset == 0 || thSize == 0) {
		return TRUE;
	}
	
	if(thOffset + thSize > dwLength) {
		return TRUE;
	}
	
	// load the thumbnail

	const BYTE *thLocation = tiffp + thOffset;
	
	FIMEMORY* hmem = FreeImage_OpenMemory(const_cast<BYTE*>(thLocation), thSize);
	FIBITMAP* thumbnail = FreeImage_LoadFromMemory(FIF_JPEG, hmem);
	FreeImage_CloseMemory(hmem);
	
	// store the thumbnail
	FreeImage_SetThumbnail(dib, thumbnail);
	// then delete it
	FreeImage_Unload(thumbnail);

	return TRUE;
}
~~~

Notice that the statement to read tagNumber and ulValue is as follows

~~~c
// get the tag ID
WORD tag = ReadUint16(msb_order, base);
DWORD offset = ReadUint32(msb_order, base + sizeof(WORD) + sizeof(WORD) + sizeof(DWORD));
~~~

When tag==TAG_JPEG_INTERCHANGE_FORMAT, it will go to the following branch to assign thOffset the value of offset

~~~c
case TAG_JPEG_INTERCHANGE_FORMAT:
    // Tiff JPEGInterchangeFormat Tag
    thOffset = offset;
    break;
~~~

Here comes the key place, in order to avoid out of bounds, the program will do a check on the sum of thOffset and thSize, the length of the requirement must not be greater than dwLength, the value is the file size. However, when the sum of thOffset and thSize is greater than the size of unsigned int, an integer overflow occurs, which in turn bypasses the check. For example, if thOffset=0xfffffe26, thSize=0x000008fe, and dwLength=0x00000a24, thOffset + thSize overflows to 0x00000724, which is less than dwLength, and bypasses the check.

~~~c
if(thOffset + thSize > dwLength) { // vulnerable check
    return TRUE;
}
~~~

The thLocation byte pointer is then defined to point to an address of size thOffset relative to the tiff file header offset, and this address is opened via FreeImage_OpenMemory, which then goes into FreeImage_LoadFromMemory. Note, however, that any address can be opened here, regardless of whether that memory space is valid, as long as the above size check is bypassed.

~~~c
const BYTE *thLocation = tiffp + thOffset;
FIMEMORY* hmem = FreeImage_OpenMemory(const_cast<BYTE*>(thLocation), thSize);
FIBITMAP* thumbnail = FreeImage_LoadFromMemory(FIF_JPEG, hmem);
~~~

Finally, it will go to the _MemoryReadProc function and finally execute to the vulnerable point, where buffer is a section of dynamically requested memory, mem_header->data is equal to the address of the hmem that has just been opened, size=1, and count is the size of the buffer, which is INPUT_BUF_SIZE by default. So this function will copy 4096 bytes from the hmem address to the buffer, and will subsequently parse or display the data in the buffer as corresponding data.

~~~c
#define INPUT_BUF_SIZE  4096	// choose an efficiently fread'able size 

unsigned DLL_CALLCONV 
_MemoryReadProc(void *buffer, unsigned size, unsigned count, fi_handle handle) {
	unsigned x;

	FIMEMORYHEADER *mem_header = (FIMEMORYHEADER*)(((FIMEMORY*)handle)->data);

	for(x = 0; x < count; x++) {
		long remaining_bytes = mem_header->file_length - mem_header->current_position;
		//if there isn't size bytes left to read, set pos to eof and return a short count
		if( remaining_bytes < (long)size ) {
			if(remaining_bytes > 0) {
				memcpy( buffer, (char *)mem_header->data + mem_header->current_position, remaining_bytes );
			}
			mem_header->current_position = mem_header->file_length;
			break;
		}
		//copy size bytes count times
		memcpy( buffer, (char *)mem_header->data + mem_header->current_position, size ); // vulnerable point
		mem_header->current_position += size;
		buffer = (char *)buffer + size;
	}
	return x;
}
~~~



---

## Vulnerability reproduce

Run the following command in windows

~~~
example.exe img
~~~

If you run the sample with the windbg debugger, you can see the following message

~~~
(6f10.8b28): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
FreeImage+0x265b3f:
00000001`80265b3f 0fb60a          movzx   ecx,byte ptr [rdx] ds:00000272`4d5bea84=??
~~~

Since FreeImage.dll has no symbol table, the stack looks as follows

~~~c
[0x0]   FreeImage + 0x265b3f!FreeImage+0x265b3f   0xba2859e948   0x1802995be   
[0x1]   FreeImage!FreeImage_OutputMessageProc+0x5ce   0xba2859e950   0x1802b410a   
[0x2]   FreeImage!FreeImage_DeInitialise+0x12e8a   0xba2859e990   0x18002502f   
[0x3]   FreeImage + 0x2502f!FreeImage+0x2502f   0xba2859e9c0   0x18002bb5d   
[0x4]   FreeImage + 0x2bb5d!FreeImage+0x2bb5d   0xba2859ea10   0x1800234e3   
[0x5]   FreeImage + 0x234e3!FreeImage+0x234e3   0xba2859ea40   0x1802b1a3f   
[0x6]   FreeImage!FreeImage_DeInitialise+0x107bf   0xba2859ea70   0x1802a08a4   
[0x7]   FreeImage!FreeImage_LoadFromHandle+0xd4   0xba2859ef90   0x18029a72f   
[0x8]   FreeImage!FreeImage_LoadFromMemory+0x4f   0xba2859efd0   0x1802f18ca   
[0x9]   FreeImage!FreeImage_ZLibCRC32+0xffa   0xba2859f020   0x1802f316d   
[0xa]   FreeImage!FreeImage_ZLibCRC32+0x289d   0xba2859f160   0x1802b3636   
[0xb]   FreeImage!FreeImage_DeInitialise+0x123b6   0xba2859f1b0   0x1802b2081   
[0xc]   FreeImage!FreeImage_DeInitialise+0x10e01   0xba2859f220   0x1802a08a4   
[0xd]   FreeImage!FreeImage_LoadFromHandle+0xd4   0xba2859f740   0x1802a0060   
[0xe]   FreeImage!FreeImage_LoadU+0x70   0xba2859f780   0x7ff75e7a108d   
[0xf]   FuzzTest!FuzzFunctions+0x5e   0xba2859f7d0   0x7ff75e7a13f8   
[0x10]   FuzzTest!main+0x8d   0xba2859f7d0   0x7ff75e7a13f8   
[0x11]   FuzzTest!invoke_main+0x22   0xba2859f840   0x7ffb92ce257d   
[0x12]   FuzzTest!__scrt_common_main_seh+0x10c   0xba2859f840   0x7ffb92ce257d   
[0x13]   KERNEL32!BaseThreadInitThunk+0x1d   0xba2859f880   0x7ffb9382aa78   
[0x14]   ntdll!RtlUserThreadStart+0x28   0xba2859f8b0   0x0   

~~~

